<script setup lang="ts">
import * as THREE from 'three';
// @ts-ignore
import Stats from 'three/addons/libs/stats.module.js';
import { onMounted } from "vue";
// const scene = new THREE.Scene();
// const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
// const render = new THREE.WebGLRenderer()
// render.setSize(window.innerWidth, window.innerHeight)
// camera.position.z = 5;
let scene:THREE.Scene;
let camera:THREE.PerspectiveCamera;
let group: THREE.Group;
let renderer: THREE.WebGLRenderer;
let targetRotation = 0;
let targetRotationOnPointerDown = 0;

let pointerX = 0;
let pointerXOnPointerDown = 0;

let windowHalfX = window.innerWidth / 2;


scene = new THREE.Scene();
scene.background = new THREE.Color( 0xf0f0f0 );

camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
camera.position.set( 0, 150, 500 );
scene.add( camera );

const light = new THREE.PointLight( 0xffffff, 0.8 );
camera.add( light );

group = new THREE.Group();
group.position.y = 50;
scene.add( group );

const x = 0, y = 0;
const heartShape = new THREE.Shape()
    .moveTo( x + 25, y + 25 )
    .bezierCurveTo( x + 25, y + 25, x + 20, y, x, y )
    .bezierCurveTo( x - 30, y, x - 30, y + 35, x - 30, y + 35 )
    .bezierCurveTo( x - 30, y + 55, x - 10, y + 77, x + 25, y + 95 )
    .bezierCurveTo( x + 60, y + 77, x + 80, y + 55, x + 80, y + 35 )
    .bezierCurveTo( x + 80, y + 35, x + 80, y, x + 50, y )
    .bezierCurveTo( x + 35, y, x + 25, y + 25, x + 25, y + 25 );
const loader = new THREE.TextureLoader();
const texture = loader.load( 'textures/uv_grid_opengl.jpg' );

// it's necessary to apply these settings in order to correctly display the texture on a shape geometry

texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set( 0.008, 0.008 );
// @ts-ignore
function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {

  // flat shape with texture
  // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

  let geometry = new THREE.ShapeGeometry( shape );
  //
  let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { side: THREE.DoubleSide } ) );
  // mesh.position.set( x, y, z - 175 );
  // mesh.rotation.set( rx, ry, rz );
  // mesh.scale.set( s, s, s );
  // group.add( mesh );
  //
  // // flat shape
  //
  // geometry = new THREE.ShapeGeometry( shape );
  //
  // mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color, side: THREE.DoubleSide } ) );
  // mesh.position.set( x, y, z - 125 );
  // mesh.rotation.set( rx, ry, rz );
  // mesh.scale.set( s, s, s );
  // group.add( mesh );

  // extruded shape

  geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

  mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: color } ) );
  mesh.position.set( x, y, z - 75 );
  mesh.rotation.set( rx, ry, rz );
  mesh.scale.set( s, s, s );
  group.add( mesh );

  // addLineShape( shape, color, x, y, z, rx, ry, rz, s );

}
// @ts-ignore
function addLineShape( shape, color, x, y, z, rx, ry, rz, s ) {

  // lines

  shape.autoClose = true;

  const points = shape.getPoints();
  const spacedPoints = shape.getSpacedPoints( 50 );

  const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
  const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints( spacedPoints );

  // solid line

  let line = new THREE.Line( geometryPoints, new THREE.LineBasicMaterial( { color: color } ) );
  line.position.set( x, y, z - 25 );
  line.rotation.set( rx, ry, rz );
  line.scale.set( s, s, s );
  group.add( line );

  // line from equidistance sampled points

  line = new THREE.Line( geometrySpacedPoints, new THREE.LineBasicMaterial( { color: color } ) );
  line.position.set( x, y, z + 25 );
  line.rotation.set( rx, ry, rz );
  line.scale.set( s, s, s );
  group.add( line );

  // vertices from real points

  let particles = new THREE.Points( geometryPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
  particles.position.set( x, y, z + 75 );
  particles.rotation.set( rx, ry, rz );
  particles.scale.set( s, s, s );
  group.add( particles );

  // equidistance sampled points

  particles = new THREE.Points( geometrySpacedPoints, new THREE.PointsMaterial( { color: color, size: 4 } ) );
  particles.position.set( x, y, z + 125 );
  particles.rotation.set( rx, ry, rz );
  particles.scale.set( s, s, s );
  group.add( particles );

}
const extrudeSettings = { depth: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
addShape( heartShape, extrudeSettings, 0xf00000, 60, 100, 0, 0, 0, Math.PI, 1 );
renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );

let stats = new Stats();
// @ts-ignore
function onPointerDown( event ) {

  if ( event.isPrimary === false ) return;

  pointerXOnPointerDown = event.clientX - windowHalfX;
  targetRotationOnPointerDown = targetRotation;

  document.addEventListener( 'pointermove', onPointerMove );
  document.addEventListener( 'pointerup', onPointerUp );

}
// @ts-ignore
function onPointerMove( event ) {

  if ( event.isPrimary === false ) return;

  pointerX = event.clientX - windowHalfX;

  targetRotation = targetRotationOnPointerDown + ( pointerX - pointerXOnPointerDown ) * 0.02;

}

function onPointerUp() {
  // @ts-ignore
  if ( event.isPrimary === false ) return;

  document.removeEventListener( 'pointermove', onPointerMove );
  document.removeEventListener( 'pointerup', onPointerUp );

}

onMounted(() => {
  document.querySelector('#threetest')!.append(renderer.domElement)
  document.addEventListener( 'pointerdown', onPointerDown );
})
function animate() {

  requestAnimationFrame( animate );

  render();
  stats.update();

  targetRotation += 0.01;
}
animate()
function render() {

  group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
  renderer.render( scene, camera );

}

// function animate() {
//   requestAnimationFrame(animate);
//   render.render(scene, camera);
// }
// animate();
</script>

<template>
  <div id="threetest"></div>
</template>

